let express,User,expressAsyncHandler,data,bcrypt,generateToken,isAdmin,isAuth;_1cf‍.x([["default",()=>_1cf‍.o]]);_1cf‍.w("express",[["default",["express"],function(v){express=v}]]);_1cf‍.w("../models/userModel.js",[["default",["User"],function(v){User=v}]]);_1cf‍.w("express-async-handler",[["default",["expressAsyncHandler"],function(v){expressAsyncHandler=v}]]);_1cf‍.w("../data.js",[["default",["data"],function(v){data=v}]]);_1cf‍.w("bcryptjs",[["default",["bcrypt"],function(v){bcrypt=v}]]);_1cf‍.w("../utils.js",[["generateToken",["generateToken"],function(v){generateToken=v}],["isAdmin",["isAdmin"],function(v){isAdmin=v}],["isAuth",["isAuth"],function(v){isAuth=v}]]);





const userRouter=express.Router();
userRouter.get('/seed',expressAsyncHandler (async(req,res)=>
{
    const createdUsers=await User.insertMany(data.users);
    res.send({createdUsers});
}));
userRouter.post('/register',expressAsyncHandler(async(req,res)=>
{
    const user=new User({
        name:req.body.name,
        email:req.body.email,
        password:bcrypt.hashSync(req.body.password,8),
    });
    const createdUser=await user.save();
    res.send({
        _id:createdUser._id,
        name:createdUser.name,
        email:createdUser.email,
        isAdmin:createdUser.isAdmin,
        token: generateToken(createdUser),
    });
})
);
userRouter.post('/signin',expressAsyncHandler(async(req,res)=>
{
    const user=await User.findOne({email:req.body.email});
    if(user)
    {
        if(bcrypt.compareSync(req.body.password,user.password))
        {
        res.send({
            _id:user._id,
            name:user.name,
            email:user.email,
            isAdmin:user.isAdmin,
        });
        return;
    }
    }
    else{
    res.status(401).send({message:'Invalid email or password'});
    }
}
))
_1cf‍.d(userRouter);